{"noir_version":"1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec","name":"PrivatePayment","functions":[{"name":"constructor","hash":"6412629657143362574","is_unconstrained":false,"custom_attributes":["private","initializer"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"token_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"token_amount","type":{"kind":"integer","sign":"unsigned","width":128},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"include_by_timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"note_hash_read_requests","type":{"kind":"struct","path":"address_note::aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_read_requests","type":{"kind":"struct","path":"address_note::aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"key_validation_requests_and_generators","type":{"kind":"struct","path":"address_note::aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hashes","type":{"kind":"struct","path":"address_note::aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifiers","type":{"kind":"struct","path":"address_note::aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"private_call_requests","type":{"kind":"struct","path":"address_note::aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_call_requests","type":{"kind":"struct","path":"address_note::aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"struct","path":"address_note::aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"private_logs","type":{"kind":"struct","path":"address_note::aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_class_logs_hashes","type":{"kind":"struct","path":"address_note::aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"address_note::aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"address_note::aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"1004672304334401604":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3206131020419630384":{"error_kind":"fmtstring","length":75,"item_types":[]},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3738765135689704617":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"4456244908619624852":{"error_kind":"string","string":"Preimage mismatch"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"10676044680617262041":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"11732781666457836689":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14101993474458164081":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15200354114977654233":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"15760694058516861966":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17226037485472400844":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17610130137239148460":{"error_kind":"fmtstring","length":98,"item_types":[]},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"process_message","hash":"7090674480688249687","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"1004672304334401604":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3206131020419630384":{"error_kind":"fmtstring","length":75,"item_types":[]},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3738765135689704617":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"10676044680617262041":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"11732781666457836689":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14101993474458164081":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15200354114977654233":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"15760694058516861966":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17226037485472400844":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17610130137239148460":{"error_kind":"fmtstring","length":98,"item_types":[]},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"TL3N0vW6jpx5L3vcg0WQAMhzKz1wtPvHUREVroi2Paqb9yskwcxJ7SfrfC+TlIRcWhKW9J///D//73/9X//tv/zbf////uN//POv//M///mv//+//fu//9t/+y///h//9//1P//tP/773//3P//5ff8nzz//mv/HP/tPxN9/xj//2n//sX/+NX5//51//7W//66//66///o///r+E/hP4j/773/8/vbgv+d3/zvuf+3+d97/rvtfv/+N+9+8/73jnTve+P0aRoM1zIbV4A3RkA27oUcePfLokUePPHrk0SOPHnn0yKNHHj3y6JGtR7Ye2Xpk65GtR7Ye2Xpk65GtR7YeefbIs0eePfLskWePPHvk2SPPHnn2yLNHXj3y6pFXj7x65NUjrx559cirR1498uqRvUf2Htl7ZO+RvUf2Htl7ZO+RvUf2Hjl65OiRo0eOHjl65Pgb2X4fREM27IZzIX8No8EaZsNq6JGzR85v5PHBbjgXvloDjAZrmA3fyOuDb+T9QTRkw244F77SA/yNPO0Da5gNq+Fv5Dk/iIZs+Eb+tthXgx/YV4OAb+TzgTXMhtXgDdGQDbvhXPhqENAjjx559MijR/5qcI0PoiEbdsO58NUgYDRYw2xYDT2y9cjWI1uPbD3y7JFnjzx75Nkjzx559sizR5498uyRZ4+8euTVI68e+avBNT9YDd4QDdmwG86FrwYBo8EaemTvkb1H9h7Ze2Tvkb1Hjh45euTokaNHjh45euTokaNHjh45euTskbNHzh45e+TskbNHzh45e+TskbNH3j3y7pF3j7x75N0j7x5598i7R9498u6RT498euTTI58e+fTIp0c+PfLpkU+PfO7I8/drGA3WMBtWgzdEQzbshm/kv6KeXw0CRoM1zIbV4A3RkA27oUe2Htl6ZOuRqwbPB6vBG/5G9vVBNuyGc+GrQcBosIbZsBq8oUeePfLskWePvG4izTUarGE2rAZviIZs2A0366b3yN4je4/sPfJXg54feEM0ZMNuOBe+GgSMBmuYDT1y9MjRI0ePHD3yV4P+91EyvxoEjAZrmA2rwRuiIRt2Q4+8e+TdI+8e+avB8A9WgzdEQzbshnPhq0HAaLCGHvn0yKdHPj3y6ZFPj3zuyOv3axgN1jAbVoM3REM27IYeefTIo0cePfLokUePPHrk0SOPHnn0yKNHth7ZemTr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bpNuk26TbpNui26Lbotui26Lbotui26Lbotui25ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm7MksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcySwyw5zJLDLDnMksMsOcyS87LEfi9L7PeyxH4vS+z3ssR+L0vs97LEfi9L7PeyxH4vS+z3o9ug26DboNug26DboNug26DboNugm9HN6GZ0M7oZ3YxuRjejm9HN6DbpNuk26VZZ8j21yapxsNGJQUziJp6HlSUXB9GIdFt0W3RbdKssGaNwE8/DypKLg2jESVxEJwaRbk43p1vQLegWdAu6Bd2CbkG3oFvQLeiWdEu6Jd2Sbkm3pFvSLemWdEu6bbptum26bbptum26bbptum26bboduh26Hboduh26Hboduh26Hbqd54bngF0cRCNO4iI6sdy8MImbWG77w8qSi4NoxElcRCcGMYmbSDejm9HN6GZ0M7oZ3YxuRjejm9Ft0m3SbdJt0m3SbdJt0m3SbdJt0m3RbdFt0W3RbdFt0W3RbdFt0W3RzenmdHO6Od2cbk43p5vTzenmdAu6Bd2CbkG3oFvQLegWdAu6Bd2Sbkm3pFvSLemWdEu6Jd2Sbkm3TbdNt023TbdNt023TbdNt023TbdDt0O3Q7dDt0O3Q7dDt0O3Q7fz3Oz3Iw6iESdxEZ0YxCRuIt2YJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJ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","expression_width":{"Bounded":{"width":4}}},{"name":"sync_private_state","hash":"13658271159266641883","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"1004672304334401604":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3206131020419630384":{"error_kind":"fmtstring","length":75,"item_types":[]},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3738765135689704617":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"10676044680617262041":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"11732781666457836689":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14101993474458164081":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15200354114977654233":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"15760694058516861966":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17226037485472400844":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17610130137239148460":{"error_kind":"fmtstring","length":98,"item_types":[]},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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r87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87Xq/P16ny9Ol+vzter8/XqfL06X6/O16vz9ep8vTpfr87l1bm8OpdX5/LqXF6dy6tzeXUur87l1bm8OpdX5/LqXF6dy6tzeXUur87l1bm8OpdX5/LqXF6dy6tzeXUur87l1bm8OpdX5/LqXF6dy6tzeXUur87l1bm8OpdX5/LqXF6dy6tzeXUur87l1bm8OpdX5/LqXF6dy6tzeXUur87l1bm8OpdX5/LqXF6dy6tzeXUur87l1bm8OpdX5/LqXF6dy6tzeXUur87l1bm8OpdX5/LqXF6dy6tzeXUur87l1bm8OpdX5/LqXF6dy6tzeXUur87l1bm8OpdX5/LqXF6dy6tzeXUur87l1bm8OpdX5/LqXF6dy6tzeXUur87l1bm8OpdX5/LqfL8636/O96vz/ep8vzrfr873q/P96ny/Ot+vzver8/3qfL8636/O96vz/ep8vzrfr873q/P96ny/Ot+vzver8/3qfL8636/O96vz/ep8vzrfr873q/P96ny/Ot+vzver8/3qfL8636/O96vz/ep8vzrfr873q/P96ny/Ot+vzver8/3qfL8636/O96vz/ep8vzrfr873q/P96ny/Ot+vzver8/3qfL8636/O96vz/ep8vzrfr873q/P96ny/Oq/OJP/6las16dJ6JI/2o/NIH9kjfxSPnkc8j3ge8TziecTziOcRzyOeRzyPeB75PPJ55PPI55HPI59HPo98Hvk8cjyqcenSeiSP9qPzSB/ZI38Uj57Heh7reaznsZ7Heh7reaznsZ7Heh7recjzkOchz0OehzwPeR7yPOR5yPOQ57Gfx34e+3ns57Gfx34e+3ns57Gfx34e53mc53Gex3ke53mc53Gex3ke53mc56HPQ5+HPg99Hvo89Hno89Dnoc9Dn4c9D3se9jzsedjzsOdhz8Oehz2PV+fn1fl5dX5enZ9X59UC5Vakj+yRP4pHOVR13rQeyaP9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","expression_width":{"Bounded":{"width":4}}}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"PrivatePayment::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PrivatePayment::constructor_parameters","fields":[{"name":"token_address","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"token_amount","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]},{"kind":"struct","path":"PrivatePayment::process_message_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PrivatePayment::process_message_parameters","fields":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"address_note::aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}}]},{"kind":"struct","path":"PrivatePayment::sync_private_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PrivatePayment::sync_private_state_parameters","fields":[]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"ContractInstanceRegistry"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"updated_class_ids","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Token"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"private_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}},{"name":"minter","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000a"}}]}},{"name":"upgrade_authority","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000c"}}]}},{"name":"asset","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"000000000000000000000000000000000000000000000000000000000000000e"}}]}}]}}]},{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"PrivatePayment"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"token_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"token_amount","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"commitment","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"50":{"source":"use aztec::macros::aztec;\n\npub mod types;\n\n#[aztec]\npub contract PrivatePayment {\n\n    use aztec::{\n        context::{PrivateContext, PublicContext},\n        macros::{\n            functions::{initializer, internal, private, public, utility, view},\n            storage::storage,\n        },\n        messages::logs::note::encode_and_encrypt_note,\n        protocol_types::{\n            address::AztecAddress,\n            constants::CONTRACT_INSTANCE_REGISTRY_CONTRACT_ADDRESS,\n            contract_class_id::ContractClassId,\n            traits::{FromField, ToField},\n        },\n        state_vars::{Map, public_immutable::PublicImmutable, public_mutable::PublicMutable\n        , private_immutable::PrivateImmutable\n        },\n    };\n\n    use address_note::address_note::AddressNote;\n    use uint_note::uint_note::UintNote;\n    use value_note::value_note::ValueNote;\n\n    use token_contract::Token;\n\n    #[storage]\n    struct Storage<Context> {\n        token_address: PrivateImmutable<AddressNote, Context>,\n        token_amount: PrivateImmutable<UintNote, Context>,\n        commitment: PrivateImmutable<ValueNote, Context>,\n    }\n\n    #[private]\n    #[initializer]\n    fn constructor(token_address: AztecAddress, token_amount: u128) {\n        let self_address = context.this_address();\n        let caller = context.msg_sender();\n\n        let partial_note = Token::at(token_address).initialize_transfer_commitment(\n            self_address,\n            caller,\n            self_address,\n        ).call(&mut context);\n\n        storage.token_address.initialize(AddressNote::new(token_address, self_address));\n        storage.token_amount.initialize(UintNote::new(token_amount, self_address));\n        storage.commitment.initialize(ValueNote::new(partial_note, self_address));\n    }\n}\n","path":"/home/hsh/Projects/aztec-projects/zcash_aztec_private_swaps/contract/src/main.nr"},"53":{"source":"use dep::aztec::{\n    macros::notes::note,\n    oracle::random::random,\n    protocol_types::{address::AztecAddress, traits::Packable},\n};\n\n// docs:start:address_note_def\n#[derive(Eq, Packable)]\n#[note]\npub struct AddressNote {\n    address: AztecAddress,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl AddressNote {\n    pub fn new(address: AztecAddress, owner: AztecAddress) -> Self {\n        // Safety: we use the randomness to preserve the privacy of the note recipient by preventing brute-forcing, so a\n        // malicious sender could use non-random values to make the note less private. But they already know the full\n        // note pre-image anyway, and so the recipient already trusts them to not disclose this information. We can\n        // therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        AddressNote { address, owner, randomness }\n    }\n\n    pub fn get_address(self) -> AztecAddress {\n        self.address\n    }\n}\n// docs:end:address_note_def\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/address-note/src/address_note.nr"},"64":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"65":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"72":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between a #[private] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[private] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[private] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[private] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[private] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp =\n            inputs.historical_header.global_variables.timestamp + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// TODO(https://github.com/AztecProtocol/aztec-packages/issues/14025) - we\n    /// are considering making msg_sender: Option<AztecAddress>, since\n    /// a returned value of `Option:none` will be clearer to developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `-1` for the first function call of the tx.\n    ///\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[private] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[private]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some historical block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[private] macro.\n    ///\n    /// # Arguments\n    /// * `returns_hasher` - A hasher containing the return values to hash\n    ///\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[private] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a heft function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"74":{"source":"use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr"},"75":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"77":{"source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/event/event_selector.nr"},"79":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/hash.nr"},"96":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr"},"100":{"source":"use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"105":{"source":"use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n\n    if is_fn_private(f) {\n        if is_static_call {\n            create_private_static_stub(f)\n        } else {\n            create_private_stub(f)\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            create_public_static_stub(f)\n        } else {\n            create_public_stub(f)\n        }\n    } else {\n        create_utility_stub(f)\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr"},"106":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"109":{"source":"use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY, call_interface_stubs::stub_fn, stub_registry,\n    },\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_authorize_once, fn_has_noinitcheck, get_fn_visibility,\n        is_fn_contract_library_method, is_fn_initializer, is_fn_internal, is_fn_private,\n        is_fn_public, is_fn_test, is_fn_utility, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\npub(crate) comptime fn create_authorize_once_check(f: FunctionDefinition) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[private] or #[public] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_fn_private(f) {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"111":{"source":"use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/macros/notes.nr"},"114":{"source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"115":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"116":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"117":{"source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr"},"118":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"119":{"source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr"},"120":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"121":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PlaintextLen * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let env = TestEnvironment::new();\n\n        // Log decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"utilityGetIndexedTaggingSecretAsSender\").returns(\n                IndexedTaggingSecret::deserialize([69420, 1337]),\n            );\n            let _ = OracleMock::mock(\"privateIncrementAppTaggingSecretIndexAsSender\").returns(());\n\n            // Encrypt the log\n            let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the log\n            let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec =\n                BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"137":{"source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr"},"142":{"source":"use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/note/lifecycle.nr"},"149":{"source":"use protocol_types::traits::{Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr"},"152":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/note/utils.nr"},"156":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"157":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"159":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(utilityGetContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(utilityGetBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(utilityGetTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(utilityGetChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(utilityGetVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"160":{"source":"/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr"},"161":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"166":{"source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr"},"167":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/keys.nr"},"169":{"source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr"},"171":{"source":"use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(utilityGetIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(privateIncrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/notes.nr"},"173":{"source":"/// Returns an unconstrained random value. Note that it is not possible to constrain this value to prove that it is\n/// truly random: we assume that the oracle is cooperating and returning random values.\n/// In some applications this behavior might not be acceptable and other techniques might be more suitable, such as\n/// producing pseudo-random values by hashing values outside of user control (like block hashes) or secrets.\npub unconstrained fn random() -> Field {\n    rand_oracle()\n}\n\n#[oracle(utilityGetRandomField)]\nunconstrained fn rand_oracle() -> Field {}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/random.nr"},"174":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"177":{"source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 1;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. PXE is using version '1', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/oracle/version.nr"},"183":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\nuse crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    lifecycle::create_note,\n    note_emission::NoteEmission,\n    note_getter::{get_note, view_notes},\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n};\nuse crate::oracle::notes::check_nullifier_exists;\nuse crate::state_vars::storage::HasStorageSlot;\n\n/// PrivateImmutable\n///\n/// PrivateImmutable is a private state variable type for values that are set once\n/// and remain permanently unchanged.\n///\n/// You can declare a state variable of type PrivateImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PrivateImmutable<YourNote, Context>`\n///\n/// The value is represented as a single note that persists for the lifetime of\n/// the state variable. Once initialized, this note is never nullified or replaced\n/// through the state variable interface - it can only be read.\n///\n/// The PrivateImmutable type facilitates: inserting the permanent note during\n/// initialization, and reading that note.\n///\n/// The methods of PrivateImmutable are:\n/// - `initialize`\n/// - `get_note`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A contract's configuration parameters can be represented as a PrivateImmutable.\n/// Once set during contract deployment or initial setup, these parameters remain\n/// constant for the lifetime of the contract.\n///\n/// ## Privacy\n///\n/// PrivateImmutable has the same privacy properties as PrivateMutable (see\n/// PrivateMutable documentation), including the same privacy considerations\n/// regarding the initialization nullifier potentially leaking information about\n/// which storage slot was initialized.\n///\n/// # Generic Parameters:\n///\n/// * `Note` - A single note of this type will represent the PrivateImmutable's\n///            value at the given storage_slot.\n/// * `Context` - The execution context (PrivateContext or UtilityContext).\n///\n/// docs:start:struct\npub struct PrivateImmutable<Note, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:struct\n\n// Private storage slots are not really 'slots' but rather a value in the note hash preimage, so there is no notion of a\n// value spilling over multiple slots. For this reason PrivateImmutable (and all other private state variables) needs\n// just one slot to be reserved, regardless of what it stores.\nimpl<T, Context> HasStorageSlot<1> for PrivateImmutable<T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateImmutable<Note, Context> {\n    /// Initializes a new PrivateImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. The permanent note for this PrivateImmutable\n    ///                    state variable will have this `storage_slot`.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n    // docs:end:new\n\n    /// Computes the nullifier that will be created when this PrivateImmutable is\n    /// initialized.\n    ///\n    /// This function is primarily used internally by the `initialize` method, but\n    /// may also be useful for contracts that need to check if a PrivateImmutable\n    /// has been initialized.\n    ///\n    /// **IMPORTANT PRIVACY CONSIDERATION:**\n    /// This computation has the same privacy implications as PrivateMutable's\n    /// initialization nullifier (see PrivateMutable documentation for detailed\n    /// explanation). The initialization nullifier can leak information about which\n    /// storage slot was initialized.\n    ///\n    /// See https://github.com/AztecProtocol/aztec-packages/issues/15568 for ideas to\n    /// improve this privacy footgun in future.\n    ///\n    /// # Returns\n    ///\n    /// * `Field` - The nullifier that will be emitted when this PrivateImmutable is\n    ///             initialized.\n    ///\n    /// # Advanced\n    ///\n    /// The computation uses the Poseidon2 hash function with a specific generator\n    /// index to hash the storage slot, creating a deterministic nullifier based on\n    /// the storage location.\n    ///\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<Note> PrivateImmutable<Note, &mut PrivateContext> {\n    /// Initializes a PrivateImmutable state variable instance with a permanent note.\n    ///\n    /// This function inserts the single, permanent note for this state variable. It can\n    /// only be called once per PrivateImmutable. Subsequent calls will fail because\n    /// the initialization nullifier will already exist.\n    ///\n    /// Unlike PrivateMutable, this note will never be nullified or replaced through\n    /// the state variable interface - it persists for the lifetime of the state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `note` - The permanent note to store in this PrivateImmutable. This note\n    ///            contains the unchanging value of the state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `NoteEmission<Note>` - A type-safe wrapper that requires you to decide\n    ///                          whether to encrypt and send the note to someone.\n    ///                          You can call `.emit()` on it to encrypt and log\n    ///                          the note, or `.discard()` to skip emission.\n    ///                          See NoteEmission for more details.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Inserts the provided note into the protocol's Note Hash Tree.\n    /// - Returns a NoteEmission type that allows the caller to decide how to encrypt\n    ///   and deliver the note to its intended recipient.\n    ///\n    /// The initialization nullifier is deterministically computed from the storage\n    /// slot and can leak privacy information (see `compute_initialization_nullifier`\n    /// documentation).\n    ///\n    /// docs:start:initialize\n    pub fn initialize(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: NoteType + NoteHash + Packable,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:initialize\n\n    /// Reads the permanent note of a PrivateImmutable state variable instance.\n    ///\n    /// If this PrivateImmutable state variable has not yet been initialized,\n    /// no note will exist: the call will fail and the transaction will not\n    /// be provable.\n    ///\n    /// # Returns\n    ///\n    /// * `Note` - The permanent note stored in this PrivateImmutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Retrieves the note from the PXE via an oracle call\n    /// - Validates that the note exists and belongs to this contract address and\n    ///   storage slot by pushing a read request to the context\n    /// - Returns the note content directly without nullification\n    ///\n    /// Since the note is immutable, there's no risk of reading stale data or\n    /// race conditions - the note never changes after initialization.\n    ///\n    /// docs:start:get_note\n    pub fn get_note(self) -> Note\n    where\n        Note: NoteType + NoteHash + Packable,\n    {\n        let storage_slot = self.storage_slot;\n        let retrieved_note = get_note(self.context, storage_slot).0;\n\n        // Because the notes obtained from PrivateImmutable are not meant to be nullified and get_note(...) function\n        // has already constrained the note (by pushing a read request to the context), we can return just the note\n        // and skip the additional data in RetrievedNote.\n        retrieved_note.note\n    }\n    // docs:end:get_note\n}\n\nimpl<Note> PrivateImmutable<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    /// Checks whether this PrivateImmutable has been initialized.\n    ///\n    /// # Returns\n    ///\n    /// * `bool` - `true` if the PrivateImmutable has been initialized (the initialization\n    ///            nullifier exists), `false` otherwise.\n    ///\n    /// docs:start:is_initialized\n    pub unconstrained fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        check_nullifier_exists(nullifier)\n    }\n    // docs:end:is_initialized\n\n    /// Returns the permanent note in this PrivateImmutable without consuming it.\n    ///\n    /// This function is only available in a UtilityContext (unconstrained environment)\n    /// and is typically used for off-chain queries, view functions, or testing.\n    ///\n    /// Unlike the constrained `get_note()`, this function does not push read requests\n    /// or perform validation. It simply reads the note from the PXE's database.\n    ///\n    /// # Returns\n    ///\n    /// * `Note` - The permanent note stored in this PrivateImmutable.\n    ///\n    /// docs:start:view_note\n    pub unconstrained fn view_note(self) -> Note\n    where\n        Note: Packable,\n    {\n        let mut options = NoteViewerOptions::<Note, <Note as Packable>::N>::new();\n        view_notes(self.storage_slot, options.set_limit(1)).get(0)\n    }\n    // docs:end:view_note\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/state_vars/private_immutable.nr"},"207":{"source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"210":{"source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"211":{"source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"213":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"214":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"216":{"source":"use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/field.nr"},"218":{"source":"use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"230":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/hsh/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"295":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"298":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Empty, Serialize, ToField},\n};\nuse std::meta::derive;\n\n// Partial address\n#[derive(Deserialize, Eq, Serialize)]\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Empty for PartialAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\nmod test {\n    use crate::{address::partial_address::PartialAddress, traits::{Deserialize, Serialize}};\n\n    #[test]\n    fn serialization_of_partial_address() {\n        let item = PartialAddress::from_field(1);\n        let serialized: [Field; 1] = item.serialize();\n        let deserialized = PartialAddress::deserialize(serialized);\n        assert_eq(item, deserialized);\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr"},"300":{"source":"use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\n#[derive(Eq)]\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr"},"304":{"source":"use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n\nmod test {\n    use crate::{\n        address::AztecAddress,\n        constants::CONTRACT_INSTANCE_LENGTH,\n        contract_class_id::ContractClassId,\n        contract_instance::ContractInstance,\n        public_keys::PublicKeys,\n        traits::{Deserialize, FromField, Serialize},\n    };\n\n    #[test]\n    fn serde() {\n        let instance = ContractInstance {\n            salt: 6,\n            deployer: AztecAddress::from_field(12),\n            contract_class_id: ContractClassId::from_field(13),\n            initialization_hash: 156,\n            public_keys: PublicKeys::default(),\n        };\n\n        // We use the CONTRACT_INSTANCE_LENGTH constant to ensure that there is a match between the derived trait\n        // implementation and the constant.\n        let serialized: [Field; CONTRACT_INSTANCE_LENGTH] = instance.serialize();\n\n        let deserialized = ContractInstance::deserialize(serialized);\n\n        assert(instance.eq(deserialized));\n    }\n\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"311":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"320":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        // Q: I don't understand this comment. We could still compute a siloed nullifier from a zero contract address.\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"334":{"source":"/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut result = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         result\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Serialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the serialized member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize(self.$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    result[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; _];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Serialize::serialize(self.$param_name)\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"335":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"336":{"source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"346":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"361":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"363":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"364":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"384":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"444":{"source":"use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/uint-note/src/uint_note.nr"},"449":{"source":"use aztec::{\n    macros::notes::note,\n    oracle::random::random,\n    protocol_types::{address::AztecAddress, traits::Packable},\n};\n\n// docs:start:value-note-def\n#[derive(Eq, Packable)]\n#[note]\npub struct ValueNote {\n    value: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n// docs:end:value-note-def\n\nimpl ValueNote {\n    pub fn new(value: Field, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        ValueNote { value, owner, randomness }\n    }\n\n    pub fn value(self) -> Field {\n        self.value\n    }\n}\n","path":"/home/hsh/nargo/github.com/AztecProtocol/aztec-packages/v2.0.3/noir-projects/aztec-nr/value-note/src/value_note.nr"}}}